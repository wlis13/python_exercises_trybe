[
    {
        "label": "exit_app",
        "importPath": "source.services",
        "description": "source.services",
        "isExtraImport": true,
        "detail": "source.services",
        "documentation": {}
    },
    {
        "label": "insert_task",
        "importPath": "source.services",
        "description": "source.services",
        "isExtraImport": true,
        "detail": "source.services",
        "documentation": {}
    },
    {
        "label": "get_all_tasks",
        "importPath": "source.services",
        "description": "source.services",
        "isExtraImport": true,
        "detail": "source.services",
        "documentation": {}
    },
    {
        "label": "completed_task",
        "importPath": "source.services",
        "description": "source.services",
        "isExtraImport": true,
        "detail": "source.services",
        "documentation": {}
    },
    {
        "label": "remove_task",
        "importPath": "source.services",
        "description": "source.services",
        "isExtraImport": true,
        "detail": "source.services",
        "documentation": {}
    },
    {
        "label": "db_insert_task",
        "importPath": "source.data_base",
        "description": "source.data_base",
        "isExtraImport": true,
        "detail": "source.data_base",
        "documentation": {}
    },
    {
        "label": "db_completed_task",
        "importPath": "source.data_base",
        "description": "source.data_base",
        "isExtraImport": true,
        "detail": "source.data_base",
        "documentation": {}
    },
    {
        "label": "db_get_one_task",
        "importPath": "source.data_base",
        "description": "source.data_base",
        "isExtraImport": true,
        "detail": "source.data_base",
        "documentation": {}
    },
    {
        "label": "db_list_not_complet_tasks",
        "importPath": "source.data_base",
        "description": "source.data_base",
        "isExtraImport": true,
        "detail": "source.data_base",
        "documentation": {}
    },
    {
        "label": "db_remove_task",
        "importPath": "source.data_base",
        "description": "source.data_base",
        "isExtraImport": true,
        "detail": "source.data_base",
        "documentation": {}
    },
    {
        "label": "db_get_all_tasks",
        "importPath": "source.data_base",
        "description": "source.data_base",
        "isExtraImport": true,
        "detail": "source.data_base",
        "documentation": {}
    },
    {
        "label": "db_update_task",
        "importPath": "source.data_base",
        "description": "source.data_base",
        "isExtraImport": true,
        "detail": "source.data_base",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "list_not_complet_task",
        "importPath": "source.util.data_base_util",
        "description": "source.util.data_base_util",
        "isExtraImport": true,
        "detail": "source.util.data_base_util",
        "documentation": {}
    },
    {
        "label": "DATABASE_PATH",
        "importPath": "source.constants",
        "description": "source.constants",
        "isExtraImport": true,
        "detail": "source.constants",
        "documentation": {}
    },
    {
        "label": "remove_zero",
        "importPath": "source.util.service_util",
        "description": "source.util.service_util",
        "isExtraImport": true,
        "detail": "source.util.service_util",
        "documentation": {}
    },
    {
        "label": "prepare_values",
        "importPath": "source.util.service_util",
        "description": "source.util.service_util",
        "isExtraImport": true,
        "detail": "source.util.service_util",
        "documentation": {}
    },
    {
        "label": "sort_data_base",
        "importPath": "source.util.service_util",
        "description": "source.util.service_util",
        "isExtraImport": true,
        "detail": "source.util.service_util",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "# noqa: F401\n    main",
        "importPath": "src.hex_converter",
        "description": "src.hex_converter",
        "isExtraImport": true,
        "detail": "src.hex_converter",
        "documentation": {}
    },
    {
        "label": "print_hexadecimal_to_decimal",
        "importPath": "src.hex_converter",
        "description": "src.hex_converter",
        "isExtraImport": true,
        "detail": "src.hex_converter",
        "documentation": {}
    },
    {
        "label": "write_hexadecimal_to_decimal",
        "importPath": "src.hex_converter",
        "description": "src.hex_converter",
        "isExtraImport": true,
        "detail": "src.hex_converter",
        "documentation": {}
    },
    {
        "label": "hexadecimal_to_decimal",
        "importPath": "src.hex_converter",
        "description": "src.hex_converter",
        "isExtraImport": true,
        "detail": "src.hex_converter",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "Faker",
        "importPath": "faker",
        "description": "faker",
        "isExtraImport": true,
        "detail": "faker",
        "documentation": {}
    },
    {
        "label": "Faker",
        "importPath": "faker",
        "description": "faker",
        "isExtraImport": true,
        "detail": "faker",
        "documentation": {}
    },
    {
        "label": "Faker",
        "importPath": "faker",
        "description": "faker",
        "isExtraImport": true,
        "detail": "faker",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randint",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "BaseProvider",
        "importPath": "faker.providers",
        "description": "faker.providers",
        "isExtraImport": true,
        "detail": "faker.providers",
        "documentation": {}
    },
    {
        "label": "dates_locales",
        "importPath": "data_values",
        "description": "data_values",
        "isExtraImport": true,
        "detail": "data_values",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "csv",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "csv",
        "description": "csv",
        "detail": "csv",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "spotify",
        "importPath": "src",
        "description": "src",
        "isExtraImport": true,
        "detail": "src",
        "documentation": {}
    },
    {
        "label": "lines_with_word_occurrences",
        "importPath": "src.word_finder",
        "description": "src.word_finder",
        "isExtraImport": true,
        "detail": "src.word_finder",
        "documentation": {}
    },
    {
        "label": "factorial",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "list_not_complet_task",
        "kind": 2,
        "importPath": "Task_manager.source.util.data_base_util",
        "description": "Task_manager.source.util.data_base_util",
        "peekOfCode": "def list_not_complet_task(content):\n    tasks = [task for task in content if task[\"completed\"] is False]\n    return tasks",
        "detail": "Task_manager.source.util.data_base_util",
        "documentation": {}
    },
    {
        "label": "remove_zero",
        "kind": 2,
        "importPath": "Task_manager.source.util.service_util",
        "description": "Task_manager.source.util.service_util",
        "peekOfCode": "def remove_zero(id):\n    if int(id) < 10 and len(id) < 2:\n        return f\"0{id}\"\n    else:\n        return id\ndef create_id(content):\n    if len(content) < 10:\n        id_value = f\"0{int(len(content)) + 1}\"\n    else:\n        id_value = f\"{int(len(content)) + 1}\"",
        "detail": "Task_manager.source.util.service_util",
        "documentation": {}
    },
    {
        "label": "create_id",
        "kind": 2,
        "importPath": "Task_manager.source.util.service_util",
        "description": "Task_manager.source.util.service_util",
        "peekOfCode": "def create_id(content):\n    if len(content) < 10:\n        id_value = f\"0{int(len(content)) + 1}\"\n    else:\n        id_value = f\"{int(len(content)) + 1}\"\n    return id_value\ndef sort_id(id, content):\n    if len(content) > 0:\n        for value in content:\n            if value[\"id\"] == id:",
        "detail": "Task_manager.source.util.service_util",
        "documentation": {}
    },
    {
        "label": "sort_id",
        "kind": 2,
        "importPath": "Task_manager.source.util.service_util",
        "description": "Task_manager.source.util.service_util",
        "peekOfCode": "def sort_id(id, content):\n    if len(content) > 0:\n        for value in content:\n            if value[\"id\"] == id:\n                id = int(id) - 1\n                break\n        return str(id)\n    else:\n        return id\ndef prepare_values(title, description, content):",
        "detail": "Task_manager.source.util.service_util",
        "documentation": {}
    },
    {
        "label": "prepare_values",
        "kind": 2,
        "importPath": "Task_manager.source.util.service_util",
        "description": "Task_manager.source.util.service_util",
        "peekOfCode": "def prepare_values(title, description, content):\n    new_id = sort_id(create_id(content), content)\n    return {\n        \"id\": new_id,\n        \"title\": title,\n        \"description\": description,\n        \"completed\": False,\n    }\ndef sort_data_base(content):\n    sorted_data_base = sorted(content, key=lambda x: int(x[\"id\"]))",
        "detail": "Task_manager.source.util.service_util",
        "documentation": {}
    },
    {
        "label": "sort_data_base",
        "kind": 2,
        "importPath": "Task_manager.source.util.service_util",
        "description": "Task_manager.source.util.service_util",
        "peekOfCode": "def sort_data_base(content):\n    sorted_data_base = sorted(content, key=lambda x: int(x[\"id\"]))\n    return sorted_data_base",
        "detail": "Task_manager.source.util.service_util",
        "documentation": {}
    },
    {
        "label": "get_options",
        "kind": 2,
        "importPath": "Task_manager.source.cli",
        "description": "Task_manager.source.cli",
        "peekOfCode": "def get_options():\n    return (\n        [\"Sair\", exit_app],\n        [\"Adicionar tarefa\", db_insert_task],\n        [\"Completar tarefa\", db_completed_task],\n        [\"Atualizar tarefa\", db_update_task],\n        [\"Listar todas as tarefas\", db_get_all_tasks],\n        [\"Listar uma tarefa\", db_get_one_task],\n        [\"Listar tarefas pendêntes\", db_list_not_complet_tasks],\n        [\"Deletar tarefa\", db_remove_task],",
        "detail": "Task_manager.source.cli",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Task_manager.source.cli",
        "description": "Task_manager.source.cli",
        "peekOfCode": "def main():\n    while True:\n        print(\"> Opções:\")\n        print(\"\")\n        for index, option in enumerate(get_options()):\n            print(f\"{index + 1}: {option[0]}\")\n        selected_option = int(input(\"> Digite a opção desejada: \"))\n        try:\n            selected_option = get_options()[selected_option - 1][1]\n            selected_option()",
        "detail": "Task_manager.source.cli",
        "documentation": {}
    },
    {
        "label": "DATABASE_PATH",
        "kind": 5,
        "importPath": "Task_manager.source.constants",
        "description": "Task_manager.source.constants",
        "peekOfCode": "DATABASE_PATH = os.environ[\"TSK_DB_PATH\"]",
        "detail": "Task_manager.source.constants",
        "documentation": {}
    },
    {
        "label": "db_get_all_tasks",
        "kind": 2,
        "importPath": "Task_manager.source.data_base",
        "description": "Task_manager.source.data_base",
        "peekOfCode": "def db_get_all_tasks():\n    content = get_all_tasks()\n    for value in content:\n        print(\n            f\"\"\"\n            Título - {value[\"title\"]}\n            Descrição - {value[\"description\"]}\n            Completa - {str(value[\"completed\"]).upper()}\n            \"\"\"\n        )",
        "detail": "Task_manager.source.data_base",
        "documentation": {}
    },
    {
        "label": "db_insert_task",
        "kind": 2,
        "importPath": "Task_manager.source.data_base",
        "description": "Task_manager.source.data_base",
        "peekOfCode": "def db_insert_task():\n    title = input(\"Digite o título da nova tarefa: \")\n    description = input(\"Digite a descrição da nova tarefa: \")\n    insert_task(title, description)\ndef db_completed_task():\n    content = get_all_tasks()\n    tasks_not_complet = list_not_complet_task(content)\n    for index, value in enumerate(tasks_not_complet):\n        print(f\"{index + 1} - {value['title']}\")\n    get_input = input(",
        "detail": "Task_manager.source.data_base",
        "documentation": {}
    },
    {
        "label": "db_completed_task",
        "kind": 2,
        "importPath": "Task_manager.source.data_base",
        "description": "Task_manager.source.data_base",
        "peekOfCode": "def db_completed_task():\n    content = get_all_tasks()\n    tasks_not_complet = list_not_complet_task(content)\n    for index, value in enumerate(tasks_not_complet):\n        print(f\"{index + 1} - {value['title']}\")\n    get_input = input(\n        \"Digite o número referente a função que você deseja completar: \"\n    )\n    choosed_task = tasks_not_complet[int(get_input) - 1][\"id\"]\n    completed_task(choosed_task)",
        "detail": "Task_manager.source.data_base",
        "documentation": {}
    },
    {
        "label": "db_update_task",
        "kind": 2,
        "importPath": "Task_manager.source.data_base",
        "description": "Task_manager.source.data_base",
        "peekOfCode": "def db_update_task():\n    return True\ndef db_get_one_task():\n    content = get_all_tasks()\n    input_title = input(\"Digite o título da tarefa desejada: \")\n    return [task for task in content if task[\"title\"] == input_title][0]\ndef db_list_not_complet_tasks():\n    content = get_all_tasks()\n    return list_not_complet_task(content)\ndef db_remove_task():",
        "detail": "Task_manager.source.data_base",
        "documentation": {}
    },
    {
        "label": "db_get_one_task",
        "kind": 2,
        "importPath": "Task_manager.source.data_base",
        "description": "Task_manager.source.data_base",
        "peekOfCode": "def db_get_one_task():\n    content = get_all_tasks()\n    input_title = input(\"Digite o título da tarefa desejada: \")\n    return [task for task in content if task[\"title\"] == input_title][0]\ndef db_list_not_complet_tasks():\n    content = get_all_tasks()\n    return list_not_complet_task(content)\ndef db_remove_task():\n    content = get_all_tasks()\n    input_title = input(\"Digite o título da tafefa que você quer remover: \")",
        "detail": "Task_manager.source.data_base",
        "documentation": {}
    },
    {
        "label": "db_list_not_complet_tasks",
        "kind": 2,
        "importPath": "Task_manager.source.data_base",
        "description": "Task_manager.source.data_base",
        "peekOfCode": "def db_list_not_complet_tasks():\n    content = get_all_tasks()\n    return list_not_complet_task(content)\ndef db_remove_task():\n    content = get_all_tasks()\n    input_title = input(\"Digite o título da tafefa que você quer remover: \")\n    for value in content:\n        if value[\"title\"] == input_title:\n            remove_task(value[\"id\"])\n        else:",
        "detail": "Task_manager.source.data_base",
        "documentation": {}
    },
    {
        "label": "db_remove_task",
        "kind": 2,
        "importPath": "Task_manager.source.data_base",
        "description": "Task_manager.source.data_base",
        "peekOfCode": "def db_remove_task():\n    content = get_all_tasks()\n    input_title = input(\"Digite o título da tafefa que você quer remover: \")\n    for value in content:\n        if value[\"title\"] == input_title:\n            remove_task(value[\"id\"])\n        else:\n            return \"A tarefa não existe.\"",
        "detail": "Task_manager.source.data_base",
        "documentation": {}
    },
    {
        "label": "get_all_tasks",
        "kind": 2,
        "importPath": "Task_manager.source.services",
        "description": "Task_manager.source.services",
        "peekOfCode": "def get_all_tasks():\n    try:\n        with open(DATABASE_PATH, \"r\") as file:\n            return json.load(file)\n    except json.JSONDecodeError:\n        return []\ndef get_one_task(id):\n    content = get_all_tasks()\n    if len(content) > 0:\n        for index, value in enumerate(content):",
        "detail": "Task_manager.source.services",
        "documentation": {}
    },
    {
        "label": "get_one_task",
        "kind": 2,
        "importPath": "Task_manager.source.services",
        "description": "Task_manager.source.services",
        "peekOfCode": "def get_one_task(id):\n    content = get_all_tasks()\n    if len(content) > 0:\n        for index, value in enumerate(content):\n            if content[index][\"id\"] is id:\n                return value\n    else:\n        return \"Sua lista de tarefas está vazia.\"\ndef insert_task(title, description):\n    content = get_all_tasks()",
        "detail": "Task_manager.source.services",
        "documentation": {}
    },
    {
        "label": "insert_task",
        "kind": 2,
        "importPath": "Task_manager.source.services",
        "description": "Task_manager.source.services",
        "peekOfCode": "def insert_task(title, description):\n    content = get_all_tasks()\n    new_task = prepare_values(title, description, content)\n    content.append(new_task)\n    content = sort_data_base(content)\n    with open(DATABASE_PATH, \"w\") as file:\n        file.write(json.dumps(content))\ndef update_task(id, new_title, new_description, new_completed):\n    content = get_all_tasks()\n    for index, value in enumerate(content):",
        "detail": "Task_manager.source.services",
        "documentation": {}
    },
    {
        "label": "update_task",
        "kind": 2,
        "importPath": "Task_manager.source.services",
        "description": "Task_manager.source.services",
        "peekOfCode": "def update_task(id, new_title, new_description, new_completed):\n    content = get_all_tasks()\n    for index, value in enumerate(content):\n        if value[\"id\"] == id:\n            content[index] = {\n                \"title\": new_title,\n                \"description\": new_description,\n                \"completed\": new_completed,\n            }\n    with open(DATABASE_PATH, \"w\") as file:",
        "detail": "Task_manager.source.services",
        "documentation": {}
    },
    {
        "label": "remove_task",
        "kind": 2,
        "importPath": "Task_manager.source.services",
        "description": "Task_manager.source.services",
        "peekOfCode": "def remove_task(id):\n    content = get_all_tasks()\n    new_list = []\n    if len(content) > 0:\n        for index, value in enumerate(content):\n            if content[index][\"id\"] != remove_zero(id):\n                new_list.append(value)\n    try:\n        with open(DATABASE_PATH, \"w\") as file:\n            file.write(json.dumps(new_list))",
        "detail": "Task_manager.source.services",
        "documentation": {}
    },
    {
        "label": "completed_task",
        "kind": 2,
        "importPath": "Task_manager.source.services",
        "description": "Task_manager.source.services",
        "peekOfCode": "def completed_task(id):\n    content = get_all_tasks()\n    for index, value in enumerate(content):\n        if value[\"id\"] == id:\n            content[index][\"completed\"] = True\n    with open(DATABASE_PATH, \"w\") as file:\n        file.write(json.dumps(content))\ndef exit_app():\n    sys.exit(0)",
        "detail": "Task_manager.source.services",
        "documentation": {}
    },
    {
        "label": "exit_app",
        "kind": 2,
        "importPath": "Task_manager.source.services",
        "description": "Task_manager.source.services",
        "peekOfCode": "def exit_app():\n    sys.exit(0)",
        "detail": "Task_manager.source.services",
        "documentation": {}
    },
    {
        "label": "hexadecimal_to_decimal",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "peekOfCode": "def hexadecimal_to_decimal(hex_digit: str) -> int:\n    return int(hex_digit, 16)\ndef print_hexadecimal_to_decimal(hex_digit: str) -> None:\n    print(hexadecimal_to_decimal(hex_digit))\ndef write_hexadecimal_to_decimal(hex_digit: str, output_file: Path) -> None:\n    with open(output_file, \"w\") as file:\n        file.write(str(hexadecimal_to_decimal(hex_digit)))\ndef main() -> int:\n    input_number = input(\"Digite um número hexadecimal: \")\n    return hexadecimal_to_decimal(input_number)",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "documentation": {}
    },
    {
        "label": "print_hexadecimal_to_decimal",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "peekOfCode": "def print_hexadecimal_to_decimal(hex_digit: str) -> None:\n    print(hexadecimal_to_decimal(hex_digit))\ndef write_hexadecimal_to_decimal(hex_digit: str, output_file: Path) -> None:\n    with open(output_file, \"w\") as file:\n        file.write(str(hexadecimal_to_decimal(hex_digit)))\ndef main() -> int:\n    input_number = input(\"Digite um número hexadecimal: \")\n    return hexadecimal_to_decimal(input_number)",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "documentation": {}
    },
    {
        "label": "write_hexadecimal_to_decimal",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "peekOfCode": "def write_hexadecimal_to_decimal(hex_digit: str, output_file: Path) -> None:\n    with open(output_file, \"w\") as file:\n        file.write(str(hexadecimal_to_decimal(hex_digit)))\ndef main() -> int:\n    input_number = input(\"Digite um número hexadecimal: \")\n    return hexadecimal_to_decimal(input_number)",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "peekOfCode": "def main() -> int:\n    input_number = input(\"Digite um número hexadecimal: \")\n    return hexadecimal_to_decimal(input_number)",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.src.hex_converter",
        "documentation": {}
    },
    {
        "label": "test_monkeypatch",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "peekOfCode": "def test_monkeypatch(monkeypatch):\n    def mock_hexadecimal(_):\n        return \"a\"\n    monkeypatch.setattr(\"builtins.input\", mock_hexadecimal)\n    output = main()\n    assert output == 10\ndef test_capsys(capsys):\n    print(10)\n    captured = capsys.readouterr()\n    assert captured.out == \"10\\n\"",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "documentation": {}
    },
    {
        "label": "test_capsys",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "peekOfCode": "def test_capsys(capsys):\n    print(10)\n    captured = capsys.readouterr()\n    assert captured.out == \"10\\n\"\n    assert captured.err == \"\"\ndef test_tmp_path(tmp_path):\n    output_path = tmp_path / \"output.txt\"\n    write_hexadecimal_to_decimal(\"a\", output_path)\n    with open(output_path, \"r\") as file:\n        assert file.read() == \"10\"",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "documentation": {}
    },
    {
        "label": "test_tmp_path",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "peekOfCode": "def test_tmp_path(tmp_path):\n    output_path = tmp_path / \"output.txt\"\n    write_hexadecimal_to_decimal(\"a\", output_path)\n    with open(output_path, \"r\") as file:\n        assert file.read() == \"10\"\n# aplica o marcador de dependency para todos os testes do arquivo\npytestmark = pytest.mark.dependency  # NÃO REMOVA ESSA LINHA",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "documentation": {}
    },
    {
        "label": "pytestmark",
        "kind": 5,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "peekOfCode": "pytestmark = pytest.mark.dependency  # NÃO REMOVA ESSA LINHA",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.built_in_fixtures_test",
        "documentation": {}
    },
    {
        "label": "custom_fixture",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.conftest",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.conftest",
        "peekOfCode": "def custom_fixture():\n    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.conftest",
        "documentation": {}
    },
    {
        "label": "test_dependency_mark",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.marker_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.marker_test",
        "peekOfCode": "def test_dependency_mark():\n    assert True",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.marker_test",
        "documentation": {}
    },
    {
        "label": "test_converter",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.parametrized_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.parametrized_test",
        "peekOfCode": "def test_converter(Hexadecimal, inteiro_na_saida):\n    assert hexadecimal_to_decimal(Hexadecimal) == inteiro_na_saida",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.parametrized_test",
        "documentation": {}
    },
    {
        "label": "pytestmark",
        "kind": 5,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.parametrized_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.parametrized_test",
        "peekOfCode": "pytestmark = pytest.mark.dependency  # NÃO REMOVA ESSA LINHA\n@pytest.mark.parametrize(\n    \"Hexadecimal, inteiro_na_saida\",\n    {\n        (\"8\", 8),\n        (\"9\", 9),\n        (\"a\", 10),\n        (\"b\", 11),\n        (\"c\", 12),\n        (\"e\", 14),",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.parametrized_test",
        "documentation": {}
    },
    {
        "label": "test_expecting_a_fixture",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "peekOfCode": "def test_expecting_a_fixture(custom_fixture):\n    assert custom_fixture.pop() == 10\n    assert custom_fixture.pop() == 9\n# * teste do exercício 1\n@pytest.mark.dependency(depends=[\"test_expecting_a_fixture\"])\ndef test_expecting_the_same_fixture(custom_fixture):\n    assert custom_fixture.pop() == 8\n    assert custom_fixture.pop() == 7\n    assert custom_fixture.pop() == 6\n    assert custom_fixture.pop() == 5",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "documentation": {}
    },
    {
        "label": "test_expecting_the_same_fixture",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "peekOfCode": "def test_expecting_the_same_fixture(custom_fixture):\n    assert custom_fixture.pop() == 8\n    assert custom_fixture.pop() == 7\n    assert custom_fixture.pop() == 6\n    assert custom_fixture.pop() == 5\n    assert custom_fixture.pop() == 4\n    assert custom_fixture.pop() == 3\n    assert custom_fixture.pop() == 2\n    assert custom_fixture.pop() == 1\n    assert custom_fixture == []",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "documentation": {}
    },
    {
        "label": "test_marker_dependency_mark",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "peekOfCode": "def test_marker_dependency_mark():\n    pass\n# * teste do exercício 3\n@pytest.mark.dependency(\n    depends=[\n        \"tests/parametrized_test.py::test_converter[8-8]\",\n        \"tests/parametrized_test.py::test_converter[9-9]\",\n        \"tests/parametrized_test.py::test_converter[a-10]\",\n        \"tests/parametrized_test.py::test_converter[b-11]\",\n        \"tests/parametrized_test.py::test_converter[c-12]\",",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "documentation": {}
    },
    {
        "label": "test_parametrized",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "peekOfCode": "def test_parametrized():\n    from src.hex_converter import hexadecimal_to_decimal  # noqa\n    from tests.Markers.parametrized_test import test_converter  # noqa\n    with patch(\n        \"tests.parametrized_test.hexadecimal_to_decimal\",\n        wraps=hexadecimal_to_decimal,\n    ) as mocked:\n        test_converter(\"a\", 10)\n        mocked.assert_called_once_with(\"a\")\n        with pytest.raises(AssertionError):",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "documentation": {}
    },
    {
        "label": "test_use_of_monkeypatch",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "peekOfCode": "def test_use_of_monkeypatch():\n    from tests.built_in_fixtures_test import test_monkeypatch  # noqa\n    assert \"monkeypatch\" in inspect.signature(test_monkeypatch).parameters\n    with patch(\"src.hex_converter.hexadecimal_to_decimal\") as mocked:\n        mocked.return_value = 10\n        test_monkeypatch(monkeypatch=pytest.MonkeyPatch())\n        mocked.assert_called_once_with(\"a\")\n# * teste do exercício 5\n@pytest.mark.dependency(\n    depends=[\"tests/built_in_fixtures_test.py::test_capsys\"], scope=\"session\"",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "documentation": {}
    },
    {
        "label": "test_use_of_capsys",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "peekOfCode": "def test_use_of_capsys():\n    from tests.built_in_fixtures_test import test_capsys  # noqa\n    assert \"capsys\" in inspect.signature(test_capsys).parameters\n    mock_capsys = MagicMock()\n    with pytest.raises(AssertionError):\n        test_capsys(mock_capsys)\n    mock_capsys.readouterr.return_value.out = \"INVALID\"\n    mock_capsys.readouterr.return_value.err = \"INVALID\"\n    with pytest.raises(AssertionError):\n        test_capsys(mock_capsys)",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "documentation": {}
    },
    {
        "label": "test_use_of_tmp_path",
        "kind": 2,
        "importPath": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "description": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "peekOfCode": "def test_use_of_tmp_path():\n    from src.hex_converter import write_hexadecimal_to_decimal  # noqa\n    from tests.built_in_fixtures_test import test_tmp_path  # noqa\n    assert \"tmp_path\" in inspect.signature(test_tmp_path).parameters\n    with pytest.raises(TypeError):\n        test_tmp_path(1)\n    def _mock_write_hexadecimal_to_decimal(hex_digit, output_file):\n        if hex_digit != \"a\":\n            raise ValueError(\n                \"Você deve testar a função `write_hexadecimal_to_decimal`\"",
        "detail": "pytest_quest.python-001-exercicio-pytest-quest.tests.trybe_test",
        "documentation": {}
    },
    {
        "label": "create_user",
        "kind": 2,
        "importPath": "src.Faker_library.create_user",
        "description": "src.Faker_library.create_user",
        "peekOfCode": "def create_user(name, email):\n    return {\n        \"first_name\": name.split()[0],\n        \"last_name\": name.split()[-1],\n        \"email\": email,\n        \"email_domain\": email.split(\"@\")[-1],\n    }\nif __name__ == \"__main__\":\n    print(create_user(fake.name(), fake.email()))",
        "detail": "src.Faker_library.create_user",
        "documentation": {}
    },
    {
        "label": "fake",
        "kind": 5,
        "importPath": "src.Faker_library.create_user",
        "description": "src.Faker_library.create_user",
        "peekOfCode": "fake = Faker(locale=\"pt-BR\")\nFaker.seed(\"Wlisses\")\ndef create_user(name, email):\n    return {\n        \"first_name\": name.split()[0],\n        \"last_name\": name.split()[-1],\n        \"email\": email,\n        \"email_domain\": email.split(\"@\")[-1],\n    }\nif __name__ == \"__main__\":",
        "detail": "src.Faker_library.create_user",
        "documentation": {}
    },
    {
        "label": "dates_locales",
        "kind": 5,
        "importPath": "src.Faker_library.data_values",
        "description": "src.Faker_library.data_values",
        "peekOfCode": "dates_locales = {\n    \"pt-BR\": {\n        \"first_part\": random.choice([\"BRA\", \"SAW\", \"NYG\", \"PKI\"]),\n        \"second_part\": random.choice([\"7Y45\", \"2L54\", \"0N26\", \"1U20\"]),\n    },\n    \"es-AR\": {\n        \"first_part\": random.choice([\"AR\", \"AB\", \"AC\", \"AD\", \"AE\"]),\n        \"half_part\": random.randint(1000, 9999),\n        \"second_part\": random.choice([\"ES\", \"RS\", \"LS\"]),\n    },",
        "detail": "src.Faker_library.data_values",
        "documentation": {}
    },
    {
        "label": "MyProvider",
        "kind": 6,
        "importPath": "src.Faker_library.fake_names",
        "description": "src.Faker_library.fake_names",
        "peekOfCode": "class MyProvider(BaseProvider):\n    def car_license_plate(self) -> str:\n        for key in dates_locales.keys():\n            if fake.locales[0].replace(\"_\", \"-\") == key:\n                if \"half_part\" in dates_locales[key]:\n                    first_element = dates_locales[key][\"first_part\"]\n                    half_element = dates_locales[key][\"half_part\"]\n                    second_element = dates_locales[key][\"second_part\"]\n                    return f\"{first_element} {half_element} {second_element}\"\n                else:",
        "detail": "src.Faker_library.fake_names",
        "documentation": {}
    },
    {
        "label": "fake",
        "kind": 5,
        "importPath": "src.Faker_library.fake_names",
        "description": "src.Faker_library.fake_names",
        "peekOfCode": "fake = Faker()\nfake = Faker(locale=\"es-AR\")\nclass MyProvider(BaseProvider):\n    def car_license_plate(self) -> str:\n        for key in dates_locales.keys():\n            if fake.locales[0].replace(\"_\", \"-\") == key:\n                if \"half_part\" in dates_locales[key]:\n                    first_element = dates_locales[key][\"first_part\"]\n                    half_element = dates_locales[key][\"half_part\"]\n                    second_element = dates_locales[key][\"second_part\"]",
        "detail": "src.Faker_library.fake_names",
        "documentation": {}
    },
    {
        "label": "fake",
        "kind": 5,
        "importPath": "src.Faker_library.fake_names",
        "description": "src.Faker_library.fake_names",
        "peekOfCode": "fake = Faker(locale=\"es-AR\")\nclass MyProvider(BaseProvider):\n    def car_license_plate(self) -> str:\n        for key in dates_locales.keys():\n            if fake.locales[0].replace(\"_\", \"-\") == key:\n                if \"half_part\" in dates_locales[key]:\n                    first_element = dates_locales[key][\"first_part\"]\n                    half_element = dates_locales[key][\"half_part\"]\n                    second_element = dates_locales[key][\"second_part\"]\n                    return f\"{first_element} {half_element} {second_element}\"",
        "detail": "src.Faker_library.fake_names",
        "documentation": {}
    },
    {
        "label": "fake_second",
        "kind": 5,
        "importPath": "src.Faker_library.fake_names",
        "description": "src.Faker_library.fake_names",
        "peekOfCode": "fake_second = Faker()\nprint(fake_second.name())\nprint(fake_second.name())",
        "detail": "src.Faker_library.fake_names",
        "documentation": {}
    },
    {
        "label": "generate_user_data",
        "kind": 2,
        "importPath": "src.Faker_library.generate_user_date",
        "description": "src.Faker_library.generate_user_date",
        "peekOfCode": "def generate_user_data(name, email, phone) -> str:\n    name = name.title()\n    phone = f\"+55 {phone}\"\n    return {\"Name\": name, \"Email\": email, \"Phone\": phone}\nif __name__ == \"__main__\":\n    name = \"wlisses\"\n    email = \"wlisses@gmail.com\"\n    phone = \"3176458214\"\n    print(generate_user_data(name, email, phone))",
        "detail": "src.Faker_library.generate_user_date",
        "documentation": {}
    },
    {
        "label": "asterisks",
        "kind": 2,
        "importPath": "src.other_modules.asterisks",
        "description": "src.other_modules.asterisks",
        "peekOfCode": "def asterisks(list: List[int]) -> str:\n    result = \"\"\n    for n in list:\n        result += \"*\" * len(list)\n        if n < len(list):\n            result += \"\\n\"\n    return result\ndef other_asterisks(number: int) -> str:\n    result = \"\"\n    for n in range(number):",
        "detail": "src.other_modules.asterisks",
        "documentation": {}
    },
    {
        "label": "other_asterisks",
        "kind": 2,
        "importPath": "src.other_modules.asterisks",
        "description": "src.other_modules.asterisks",
        "peekOfCode": "def other_asterisks(number: int) -> str:\n    result = \"\"\n    for n in range(number):\n        for _ in range(number):\n            result += \"*\"\n        if n < number - 1:\n            result += \"\\n\"\n    return result",
        "detail": "src.other_modules.asterisks",
        "documentation": {}
    },
    {
        "label": "read_json_file",
        "kind": 2,
        "importPath": "src.analyzer",
        "description": "src.analyzer",
        "peekOfCode": "def read_json_file(file_path):\n    with open(file_path, \"r\") as file:\n        return json.load(file)\ndef analyze_json_file(file_path) -> str:\n    if not file_path.endswith(\".json\"):\n        raise ValueError(\"O arquivo precise ser um aquivo JSON\")\n    data = read_json_file(file_path)\n    return (\n        f\"A pessoa do nome: {data['nome']} \"\n        f\"tem {data['idade']} anos de idade.\"",
        "detail": "src.analyzer",
        "documentation": {}
    },
    {
        "label": "analyze_json_file",
        "kind": 2,
        "importPath": "src.analyzer",
        "description": "src.analyzer",
        "peekOfCode": "def analyze_json_file(file_path) -> str:\n    if not file_path.endswith(\".json\"):\n        raise ValueError(\"O arquivo precise ser um aquivo JSON\")\n    data = read_json_file(file_path)\n    return (\n        f\"A pessoa do nome: {data['nome']} \"\n        f\"tem {data['idade']} anos de idade.\"\n    )",
        "detail": "src.analyzer",
        "documentation": {}
    },
    {
        "label": "csv_for_tuple_list_file",
        "kind": 2,
        "importPath": "src.csv_for_tuple_list",
        "description": "src.csv_for_tuple_list",
        "peekOfCode": "def csv_for_tuple_list_file(path_file):\n    with open(path_file, \"r\") as file:\n        content_file = csv.DictReader(file)\n        tuple_list = []\n        for row in content_file:\n            for tn in row.items():\n                tuple_list.append(tn)\n    return tuple_list\ndef csv_for_list(path_file):\n    with open(path_file, \"r\") as file:",
        "detail": "src.csv_for_tuple_list",
        "documentation": {}
    },
    {
        "label": "csv_for_list",
        "kind": 2,
        "importPath": "src.csv_for_tuple_list",
        "description": "src.csv_for_tuple_list",
        "peekOfCode": "def csv_for_list(path_file):\n    with open(path_file, \"r\") as file:\n        content_file = csv.reader(file)\n        value = []\n        for v in content_file:\n            value.append(v)\n        return value\ndef prime_numbers(numbers: List[int]) -> Dict[str, str]:\n    result = {}\n    for num in numbers:",
        "detail": "src.csv_for_tuple_list",
        "documentation": {}
    },
    {
        "label": "prime_numbers",
        "kind": 2,
        "importPath": "src.csv_for_tuple_list",
        "description": "src.csv_for_tuple_list",
        "peekOfCode": "def prime_numbers(numbers: List[int]) -> Dict[str, str]:\n    result = {}\n    for num in numbers:\n        if num <= 1:\n            result[f\"{num}\"] = \"Não é primo\"\n        else:\n            count = 0\n            for tn in range(2, int(num**0.5) + 1):\n                if num % tn == 0:\n                    count += 1",
        "detail": "src.csv_for_tuple_list",
        "documentation": {}
    },
    {
        "label": "fib",
        "kind": 2,
        "importPath": "src.fibo",
        "description": "src.fibo",
        "peekOfCode": "def fib(n: int):\n    a, b = 0, 1\n    while a < n:\n        print(a, end=\", \")\n        a, b = b, a + b\ndef fib2(n: int) -> int:\n    if n <= 1:\n        return n\n    else:\n        return fib2(n - 1) + fib2(n - 2)",
        "detail": "src.fibo",
        "documentation": {}
    },
    {
        "label": "fib2",
        "kind": 2,
        "importPath": "src.fibo",
        "description": "src.fibo",
        "peekOfCode": "def fib2(n: int) -> int:\n    if n <= 1:\n        return n\n    else:\n        return fib2(n - 1) + fib2(n - 2)\ndef fib3(n: int) -> List[int]:\n    a, b = 0, 1\n    result = []\n    while a < n:\n        result.append(a)",
        "detail": "src.fibo",
        "documentation": {}
    },
    {
        "label": "fib3",
        "kind": 2,
        "importPath": "src.fibo",
        "description": "src.fibo",
        "peekOfCode": "def fib3(n: int) -> List[int]:\n    a, b = 0, 1\n    result = []\n    while a < n:\n        result.append(a)\n        a, b = b, a + b\n    return result\nprint(fib3(500))",
        "detail": "src.fibo",
        "documentation": {}
    },
    {
        "label": "filter_numbers",
        "kind": 2,
        "importPath": "src.handle_numbers_and_string",
        "description": "src.handle_numbers_and_string",
        "peekOfCode": "def filter_numbers(list_numbers: List[int]):\n    filtered_numbers = list(filter(lambda x: x > 10, list_numbers))\n    return filtered_numbers\ndef show_your_input():\n    return f\"Você digitou: {input('Digite alto: ')}!\"\ndef generate_output(content, path):\n    with open(path, \"w\", encoding=\"utf-8\") as file:\n        file.write(json.dumps(content))",
        "detail": "src.handle_numbers_and_string",
        "documentation": {}
    },
    {
        "label": "show_your_input",
        "kind": 2,
        "importPath": "src.handle_numbers_and_string",
        "description": "src.handle_numbers_and_string",
        "peekOfCode": "def show_your_input():\n    return f\"Você digitou: {input('Digite alto: ')}!\"\ndef generate_output(content, path):\n    with open(path, \"w\", encoding=\"utf-8\") as file:\n        file.write(json.dumps(content))",
        "detail": "src.handle_numbers_and_string",
        "documentation": {}
    },
    {
        "label": "generate_output",
        "kind": 2,
        "importPath": "src.handle_numbers_and_string",
        "description": "src.handle_numbers_and_string",
        "peekOfCode": "def generate_output(content, path):\n    with open(path, \"w\", encoding=\"utf-8\") as file:\n        file.write(json.dumps(content))",
        "detail": "src.handle_numbers_and_string",
        "documentation": {}
    },
    {
        "label": "list_numbers",
        "kind": 5,
        "importPath": "src.handle_numbers_and_string",
        "description": "src.handle_numbers_and_string",
        "peekOfCode": "list_numbers = [1, 2, 5, 8, 100, 20, 65, 89]\ndef filter_numbers(list_numbers: List[int]):\n    filtered_numbers = list(filter(lambda x: x > 10, list_numbers))\n    return filtered_numbers\ndef show_your_input():\n    return f\"Você digitou: {input('Digite alto: ')}!\"\ndef generate_output(content, path):\n    with open(path, \"w\", encoding=\"utf-8\") as file:\n        file.write(json.dumps(content))",
        "detail": "src.handle_numbers_and_string",
        "documentation": {}
    },
    {
        "label": "test_sum_elements",
        "kind": 2,
        "importPath": "tests.Decorators.another_test",
        "description": "tests.Decorators.another_test",
        "peekOfCode": "def test_sum_elements(my_list):\n    assert [num * 3 for num in my_list] == [3, 6, 9]",
        "detail": "tests.Decorators.another_test",
        "documentation": {}
    },
    {
        "label": "test_print_to_stdout",
        "kind": 2,
        "importPath": "tests.Decorators.fixtures_test",
        "description": "tests.Decorators.fixtures_test",
        "peekOfCode": "def test_print_to_stdout(capsys):\n    print(\"Hello World!\")\n    captured = capsys.readouterr()\n    assert captured.out == \"Hello World!\\n\"\ndef test_error_to_stderr(capsys):\n    import sys\n    sys.stderr.write(\"Error message\\n\")\n    captured = capsys.readouterr()\n    assert captured.err == \"Error message\\n\"\ndef test_show_your_digit(monkeypatch):",
        "detail": "tests.Decorators.fixtures_test",
        "documentation": {}
    },
    {
        "label": "test_error_to_stderr",
        "kind": 2,
        "importPath": "tests.Decorators.fixtures_test",
        "description": "tests.Decorators.fixtures_test",
        "peekOfCode": "def test_error_to_stderr(capsys):\n    import sys\n    sys.stderr.write(\"Error message\\n\")\n    captured = capsys.readouterr()\n    assert captured.err == \"Error message\\n\"\ndef test_show_your_digit(monkeypatch):\n    def mock_input(_):\n        return \"Python\"\n    monkeypatch.setattr(\"builtins.input\", mock_input)\n    output = show_your_input()",
        "detail": "tests.Decorators.fixtures_test",
        "documentation": {}
    },
    {
        "label": "test_show_your_digit",
        "kind": 2,
        "importPath": "tests.Decorators.fixtures_test",
        "description": "tests.Decorators.fixtures_test",
        "peekOfCode": "def test_show_your_digit(monkeypatch):\n    def mock_input(_):\n        return \"Python\"\n    monkeypatch.setattr(\"builtins.input\", mock_input)\n    output = show_your_input()\n    assert output == \"Você digitou: Python!\"",
        "detail": "tests.Decorators.fixtures_test",
        "documentation": {}
    },
    {
        "label": "sum_two_numbers",
        "kind": 2,
        "importPath": "tests.Doctests.doctests",
        "description": "tests.Doctests.doctests",
        "peekOfCode": "def sum_two_numbers(a, b):\n    \"\"\"Retorna a soma de dois números recebidos por parâmetro\n    Exemplos\n    --------\n    >>> sum_two_numbers(0,0)\n    0\n    >>> sum_two_numbers(2, 2)\n    4\n    \"\"\"\n    return a + b",
        "detail": "tests.Doctests.doctests",
        "documentation": {}
    },
    {
        "label": "mean",
        "kind": 2,
        "importPath": "tests.Doctests.doctests",
        "description": "tests.Doctests.doctests",
        "peekOfCode": "def mean(numbers: List[int]) -> float:\n    \"\"\"\n    Calcula a média de uma lista de números.\n    >>> my_list = [1, 2, 3, 4, 5]\n    >>> mean(my_list)\n    3.0\n    >>> mean([2.5, 3.75, 1.25, 4])\n    2.875\n    >>> mean([])\n    Divisão por zero.",
        "detail": "tests.Doctests.doctests",
        "documentation": {}
    },
    {
        "label": "sum_list",
        "kind": 2,
        "importPath": "tests.Doctests.doctests",
        "description": "tests.Doctests.doctests",
        "peekOfCode": "def sum_list(list: List[int]) -> int:\n    \"\"\"\n    Retorna a soma dos inteiros de uma lista\n    >>> sum_list([1,2,3,4,5])\n    15\n    >>> sum_list([45, 45, 10, 50])\n    150\n    \"\"\"\n    total = 0\n    for n in list:",
        "detail": "tests.Doctests.doctests",
        "documentation": {}
    },
    {
        "label": "mean",
        "kind": 2,
        "importPath": "tests.Doctests.main",
        "description": "tests.Doctests.main",
        "peekOfCode": "def mean(numbers):\n    \"\"\"\n    Calcula a média de uma lista de números.\n    >>> my_list = [1, 2, 3, 4, 5]\n    >>> mean(my_list)\n    3.0\n    >>> mean([2.5, 3.75, 1.25, 4])\n    2.875\n    >>> mean([])\n    Traceback (most recent call last):",
        "detail": "tests.Doctests.main",
        "documentation": {}
    },
    {
        "label": "test_sum_numbers",
        "kind": 2,
        "importPath": "tests.Markers.a_test",
        "description": "tests.Markers.a_test",
        "peekOfCode": "def test_sum_numbers(my_list):\n    assert sum(my_list) == 6\ndef test_fib3():\n    result = fib3(8)\n    assert result == [0, 1, 1, 2, 3, 5]\n@pytest.mark.skip(reason=\"Somente para teste.\")\ndef test_fib2():\n    result = fib2(10)\n    assert result == 55\n@pytest.mark.skipif(sys.platform == \"linux\", reason=\"Apenas para testes. \")",
        "detail": "tests.Markers.a_test",
        "documentation": {}
    },
    {
        "label": "test_fib3",
        "kind": 2,
        "importPath": "tests.Markers.a_test",
        "description": "tests.Markers.a_test",
        "peekOfCode": "def test_fib3():\n    result = fib3(8)\n    assert result == [0, 1, 1, 2, 3, 5]\n@pytest.mark.skip(reason=\"Somente para teste.\")\ndef test_fib2():\n    result = fib2(10)\n    assert result == 55\n@pytest.mark.skipif(sys.platform == \"linux\", reason=\"Apenas para testes. \")\ndef test_asterisks(high_list):\n    result = asterisks(high_list)",
        "detail": "tests.Markers.a_test",
        "documentation": {}
    },
    {
        "label": "test_fib2",
        "kind": 2,
        "importPath": "tests.Markers.a_test",
        "description": "tests.Markers.a_test",
        "peekOfCode": "def test_fib2():\n    result = fib2(10)\n    assert result == 55\n@pytest.mark.skipif(sys.platform == \"linux\", reason=\"Apenas para testes. \")\ndef test_asterisks(high_list):\n    result = asterisks(high_list)\n    assert result == \"*****\\n*****\\n*****\\n*****\\n*****\"\ndef test_other_asteriks():\n    result = other_asterisks(5)\n    assert result == \"*****\\n*****\\n*****\\n*****\\n*****\"",
        "detail": "tests.Markers.a_test",
        "documentation": {}
    },
    {
        "label": "test_asterisks",
        "kind": 2,
        "importPath": "tests.Markers.a_test",
        "description": "tests.Markers.a_test",
        "peekOfCode": "def test_asterisks(high_list):\n    result = asterisks(high_list)\n    assert result == \"*****\\n*****\\n*****\\n*****\\n*****\"\ndef test_other_asteriks():\n    result = other_asterisks(5)\n    assert result == \"*****\\n*****\\n*****\\n*****\\n*****\"\ndef test_generate_output(tmp_path):\n    content = {\"a\": 1}\n    output_path = tmp_path / \"tes_path_lib.json\"\n    generate_output(content, output_path)",
        "detail": "tests.Markers.a_test",
        "documentation": {}
    },
    {
        "label": "test_other_asteriks",
        "kind": 2,
        "importPath": "tests.Markers.a_test",
        "description": "tests.Markers.a_test",
        "peekOfCode": "def test_other_asteriks():\n    result = other_asterisks(5)\n    assert result == \"*****\\n*****\\n*****\\n*****\\n*****\"\ndef test_generate_output(tmp_path):\n    content = {\"a\": 1}\n    output_path = tmp_path / \"tes_path_lib.json\"\n    generate_output(content, output_path)\n    assert os.path.isfile(output_path)\n    with open(output_path, \"r\") as file:\n        assert file.read() == '{\"a\": 1}'",
        "detail": "tests.Markers.a_test",
        "documentation": {}
    },
    {
        "label": "test_generate_output",
        "kind": 2,
        "importPath": "tests.Markers.a_test",
        "description": "tests.Markers.a_test",
        "peekOfCode": "def test_generate_output(tmp_path):\n    content = {\"a\": 1}\n    output_path = tmp_path / \"tes_path_lib.json\"\n    generate_output(content, output_path)\n    assert os.path.isfile(output_path)\n    with open(output_path, \"r\") as file:\n        assert file.read() == '{\"a\": 1}'",
        "detail": "tests.Markers.a_test",
        "documentation": {}
    },
    {
        "label": "test_slow_mark",
        "kind": 2,
        "importPath": "tests.Markers.markers_test",
        "description": "tests.Markers.markers_test",
        "peekOfCode": "def test_slow_mark():\n    time.sleep(4)",
        "detail": "tests.Markers.markers_test",
        "documentation": {}
    },
    {
        "label": "test_mean",
        "kind": 2,
        "importPath": "tests.Markers.parametrized_test",
        "description": "tests.Markers.parametrized_test",
        "peekOfCode": "def test_mean(input_numbers, expected_result):\n    assert mean(input_numbers) == expected_result\ndef test_mean_fail():\n    with pytest.raises(ZeroDivisionError):\n        mean([])",
        "detail": "tests.Markers.parametrized_test",
        "documentation": {}
    },
    {
        "label": "test_mean_fail",
        "kind": 2,
        "importPath": "tests.Markers.parametrized_test",
        "description": "tests.Markers.parametrized_test",
        "peekOfCode": "def test_mean_fail():\n    with pytest.raises(ZeroDivisionError):\n        mean([])",
        "detail": "tests.Markers.parametrized_test",
        "documentation": {}
    },
    {
        "label": "alberto_mock_file_json",
        "kind": 5,
        "importPath": "tests.Mock_unittest.mock_json",
        "description": "tests.Mock_unittest.mock_json",
        "peekOfCode": "alberto_mock_file_json = \"\"\"\n{\n  \"nome\": \"Alberto\",\n  \"idade\": 56,\n  \"ano_de_nascimento\": 1968,\n  \"peso\": 78,\n  \"informações_de_trabalho\": {\n    \"local\": \"Belo Horizonte n° 478-Centro\",\n    \"horario_entrada\": {\n      \"numero\": 7.30,",
        "detail": "tests.Mock_unittest.mock_json",
        "documentation": {}
    },
    {
        "label": "maria_mock_file_json",
        "kind": 5,
        "importPath": "tests.Mock_unittest.mock_json",
        "description": "tests.Mock_unittest.mock_json",
        "peekOfCode": "maria_mock_file_json = \"\"\"\n  {\n    \"nome\": \"Maria\",\n    \"idade\": 30\n  }\n\"\"\"\nagenor_mock_file_json = \"\"\"\n  {\n    \"nome\": \"Agenor\",\n    \"idade\": 86",
        "detail": "tests.Mock_unittest.mock_json",
        "documentation": {}
    },
    {
        "label": "agenor_mock_file_json",
        "kind": 5,
        "importPath": "tests.Mock_unittest.mock_json",
        "description": "tests.Mock_unittest.mock_json",
        "peekOfCode": "agenor_mock_file_json = \"\"\"\n  {\n    \"nome\": \"Agenor\",\n    \"idade\": 86\n  }\n\"\"\"",
        "detail": "tests.Mock_unittest.mock_json",
        "documentation": {}
    },
    {
        "label": "test_analyze_json_file",
        "kind": 2,
        "importPath": "tests.Mock_unittest.test_analyzer",
        "description": "tests.Mock_unittest.test_analyzer",
        "peekOfCode": "def test_analyze_json_file():\n    with patch(\"builtins.open\") as mock_file:\n        mock_file.return_value.__enter__.return_value.read.return_value = (\n            maria_mock_file_json\n        )\n        assert (\n            analyze_json_file(\"invalid.json\")\n            == \"A pessoa do nome: Maria tem 30 anos de idade.\"\n        )\n    with patch(\"builtins.open\") as mock_file:",
        "detail": "tests.Mock_unittest.test_analyzer",
        "documentation": {}
    },
    {
        "label": "test_analyzer_json_file_propagates_exception",
        "kind": 2,
        "importPath": "tests.Mock_unittest.test_analyzer",
        "description": "tests.Mock_unittest.test_analyzer",
        "peekOfCode": "def test_analyzer_json_file_propagates_exception():\n    with pytest.raises(FileNotFoundError):\n        assert analyze_json_file(\"invalid.json\")\n    with patch(\"builtins.open\") as mock_file:\n        mock_file.return_value.__enter__.return_value.read.return_value = (\n            agenor_mock_file_json\n        )\n        with pytest.raises(ValueError):\n            assert analyze_json_file(\"invalid.txt\")\ndef test_read_json_file():",
        "detail": "tests.Mock_unittest.test_analyzer",
        "documentation": {}
    },
    {
        "label": "test_read_json_file",
        "kind": 2,
        "importPath": "tests.Mock_unittest.test_analyzer",
        "description": "tests.Mock_unittest.test_analyzer",
        "peekOfCode": "def test_read_json_file():\n    with patch(\"builtins.open\") as mock_file:\n        mock_file.return_value.__enter__.return_value.read.return_value = (\n            '{\"nome\": \"Maria\", \"idade\": 31}'\n        )\n        result = read_json_file(\"invalid.json\")\n        assert result == {\"nome\": \"Maria\", \"idade\": 31}\n        mock_file.assert_called_with(\"invalid.json\", \"r\")",
        "detail": "tests.Mock_unittest.test_analyzer",
        "documentation": {}
    },
    {
        "label": "test_faker_email",
        "kind": 2,
        "importPath": "tests.Tests_faker.test_faker",
        "description": "tests.Tests_faker.test_faker",
        "peekOfCode": "def test_faker_email(faker):\n    faker_email = faker.email()\n    assert isinstance(faker_email, str)\n    assert \"@\" in faker_email\n    assert \".\" in faker_email\n    assert type(faker_email) is str\ndef test_generate_user_data(faker):\n    name = faker.name()\n    email = faker.email()\n    phone = faker.phone_number()",
        "detail": "tests.Tests_faker.test_faker",
        "documentation": {}
    },
    {
        "label": "test_generate_user_data",
        "kind": 2,
        "importPath": "tests.Tests_faker.test_faker",
        "description": "tests.Tests_faker.test_faker",
        "peekOfCode": "def test_generate_user_data(faker):\n    name = faker.name()\n    email = faker.email()\n    phone = faker.phone_number()\n    result = generate_user_data(name, email, phone)\n    assert result[\"Name\"] == name\n    assert result[\"Email\"] == email\n    assert result[\"Phone\"] == f\"+55 {phone}\"\ndef test_create_user():\n    fake = Faker(locale=\"pt-BR\")",
        "detail": "tests.Tests_faker.test_faker",
        "documentation": {}
    },
    {
        "label": "test_create_user",
        "kind": 2,
        "importPath": "tests.Tests_faker.test_faker",
        "description": "tests.Tests_faker.test_faker",
        "peekOfCode": "def test_create_user():\n    fake = Faker(locale=\"pt-BR\")\n    Faker.seed(\"Wlisses\")\n    name = fake.name()\n    email = fake.email()\n    result = create_user(name, email)\n    assert name.startswith(result[\"first_name\"])\n    assert name.endswith(result[\"last_name\"])\n    assert email is result[\"email\"]\n    assert email.endswith(result[\"email_domain\"])",
        "detail": "tests.Tests_faker.test_faker",
        "documentation": {}
    },
    {
        "label": "my_list",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def my_list() -> List[int]:\n    return [1, 2, 3]\n@pytest.fixture\ndef high_list() -> List[int]:\n    return [1, 2, 3, 4, 5]\ndef pytest_configure(config):\n    config.addinivalue_line(\"markers\", \"slow: mark test as slow\")\n# configurações de localização e semente da fixture (faker)\n# configuração do locale\n@pytest.fixture(scope=\"session\", autouse=True)",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "high_list",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def high_list() -> List[int]:\n    return [1, 2, 3, 4, 5]\ndef pytest_configure(config):\n    config.addinivalue_line(\"markers\", \"slow: mark test as slow\")\n# configurações de localização e semente da fixture (faker)\n# configuração do locale\n@pytest.fixture(scope=\"session\", autouse=True)\ndef faker_locale():\n    return [\"pt-BR\"]\n# configuração da seed",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "pytest_configure",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def pytest_configure(config):\n    config.addinivalue_line(\"markers\", \"slow: mark test as slow\")\n# configurações de localização e semente da fixture (faker)\n# configuração do locale\n@pytest.fixture(scope=\"session\", autouse=True)\ndef faker_locale():\n    return [\"pt-BR\"]\n# configuração da seed\n@pytest.fixture(scope=\"session\", autouse=True)\ndef faker_seed():",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "faker_locale",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def faker_locale():\n    return [\"pt-BR\"]\n# configuração da seed\n@pytest.fixture(scope=\"session\", autouse=True)\ndef faker_seed():\n    return \"Trybe\"",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "faker_seed",
        "kind": 2,
        "importPath": "tests.conftest",
        "description": "tests.conftest",
        "peekOfCode": "def faker_seed():\n    return \"Trybe\"",
        "detail": "tests.conftest",
        "documentation": {}
    },
    {
        "label": "get_command_help",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "def get_command_help(data_path) -> str:\n    return f\"\"\"\nAnalise informações do Spotify baseado no arquivo '{data_path}'.\nModo de uso:\n    python3 src/spotify.py [ opção ]\n{get_command_options()}\n\"\"\"\ndef get_invalid_option_help(option):\n    return f\"\"\"\nOpção {repr(option)} inválida.",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "get_invalid_option_help",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "def get_invalid_option_help(option):\n    return f\"\"\"\nOpção {repr(option)} inválida.\n{get_command_options()}\n\"\"\"\ndef get_command_options() -> str:\n    return \"\"\"\nAs opções são:\n    1 - Mostrar as top 10 músicas mais instrumentais no Spotify\n    2 - Mostrar as top 10 músicas mais dançantes no Spotify",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "get_command_options",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "def get_command_options() -> str:\n    return \"\"\"\nAs opções são:\n    1 - Mostrar as top 10 músicas mais instrumentais no Spotify\n    2 - Mostrar as top 10 músicas mais dançantes no Spotify\n    3 - Mostrar as top 10 músicas mais enérgicas no Spotify\"\"\"\ndef read_csv(path: str) -> List[Dict[str, str]]:\n    \"\"\"read csv file and return list of dictionaries\"\"\"\n    with open(path, \"r\") as file:\n        return list(csv.DictReader(file))",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "read_csv",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "def read_csv(path: str) -> List[Dict[str, str]]:\n    \"\"\"read csv file and return list of dictionaries\"\"\"\n    with open(path, \"r\") as file:\n        return list(csv.DictReader(file))\ndef get_most_instrumental_songs(\n    data: List[Dict[str, str]]\n) -> List[Dict[str, str]]:\n    return sorted(\n        data, key=lambda x: float(x[\"Instrumentalness\"]), reverse=True\n    )[:10]",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "get_most_instrumental_songs",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "def get_most_instrumental_songs(\n    data: List[Dict[str, str]]\n) -> List[Dict[str, str]]:\n    return sorted(\n        data, key=lambda x: float(x[\"Instrumentalness\"]), reverse=True\n    )[:10]\ndef get_most_danceable_songs(\n    data: List[Dict[str, str]]\n) -> List[Dict[str, str]]:\n    return sorted(data, key=lambda x: float(x[\"Danceability\"]), reverse=True)[",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "get_most_danceable_songs",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "def get_most_danceable_songs(\n    data: List[Dict[str, str]]\n) -> List[Dict[str, str]]:\n    return sorted(data, key=lambda x: float(x[\"Danceability\"]), reverse=True)[\n        :10\n    ]\ndef get_most_energetic_songs(\n    data: List[Dict[str, str]]\n) -> List[Dict[str, str]]:\n    return sorted(data, key=lambda x: float(x[\"Energy\"]), reverse=True)[:10]",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "get_most_energetic_songs",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "def get_most_energetic_songs(\n    data: List[Dict[str, str]]\n) -> List[Dict[str, str]]:\n    return sorted(data, key=lambda x: float(x[\"Energy\"]), reverse=True)[:10]\nOPTIONS = {\n    \"1\": (\"instrumentais\", get_most_instrumental_songs),\n    \"2\": (\"dançantes\", get_most_danceable_songs),\n    \"3\": (\"enérgicas\", get_most_energetic_songs),\n}\ndef process_music_analysis(data, option) -> None:",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "process_music_analysis",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "def process_music_analysis(data, option) -> None:\n    print(f\"Top 10 músicas mais {OPTIONS[option][0]}:\")\n    for index, song in enumerate(OPTIONS[option][1](data), start=1):\n        print(f\"{index:>2} - '{song['Track']}' de {song['Artist']}\")\ndef handle_user_input(data, option) -> None:\n    if option not in OPTIONS:\n        print(get_invalid_option_help(option))\n        raise ValueError\n    else:\n        process_music_analysis(data, option)",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "handle_user_input",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "def handle_user_input(data, option) -> None:\n    if option not in OPTIONS:\n        print(get_invalid_option_help(option))\n        raise ValueError\n    else:\n        process_music_analysis(data, option)\ndef main(file_path) -> int:\n    cli_args = sys.argv[1:]\n    if not cli_args:\n        print(get_command_help(file_path))",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "def main(file_path) -> int:\n    cli_args = sys.argv[1:]\n    if not cli_args:\n        print(get_command_help(file_path))\n        return 1\n    \"\"\"recebe o arquivo spotify como uma lista de dicionários do tipo string\"\"\"\n    data = read_csv(file_path)\n    try:\n        handle_user_input(data, cli_args[0])\n    except ValueError:",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "DATA_PATH",
        "kind": 5,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "DATA_PATH = \"data/spotify.csv\"\ndef get_command_help(data_path) -> str:\n    return f\"\"\"\nAnalise informações do Spotify baseado no arquivo '{data_path}'.\nModo de uso:\n    python3 src/spotify.py [ opção ]\n{get_command_options()}\n\"\"\"\ndef get_invalid_option_help(option):\n    return f\"\"\"",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "OPTIONS",
        "kind": 5,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "peekOfCode": "OPTIONS = {\n    \"1\": (\"instrumentais\", get_most_instrumental_songs),\n    \"2\": (\"dançantes\", get_most_danceable_songs),\n    \"3\": (\"enérgicas\", get_most_energetic_songs),\n}\ndef process_music_analysis(data, option) -> None:\n    print(f\"Top 10 músicas mais {OPTIONS[option][0]}:\")\n    for index, song in enumerate(OPTIONS[option][1](data), start=1):\n        print(f\"{index:>2} - '{song['Track']}' de {song['Artist']}\")\ndef handle_user_input(data, option) -> None:",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.spotify",
        "documentation": {}
    },
    {
        "label": "lines_with_word_occurrences",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.word_finder",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.word_finder",
        "peekOfCode": "def lines_with_word_occurrences(file_path: str, word: str):\n    str_lines = read_file_lines(file_path)\n    result = []\n    count_index = 0\n    for index in range(1, 34):\n        print(index)\n        count_index += 1\n        if word.casefold() in str_lines[count_index - 1].casefold():\n            result.append(count_index)\n        else:",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.word_finder",
        "documentation": {}
    },
    {
        "label": "read_file_lines",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.word_finder",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.word_finder",
        "peekOfCode": "def read_file_lines(file_path):\n    with open(file_path, \"r\") as file:\n        file_content = file.read()\n    return file_content.split()\ndef main():\n    file_path = \"data/word_finder.txt\"\n    search_word = \"python\"\n    occurrences = lines_with_word_occurrences(file_path, search_word)\n    print(\n        f'A palavra \"{search_word}\" ocorre nas seguintes linhas do arquivo:',",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.word_finder",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.word_finder",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.word_finder",
        "peekOfCode": "def main():\n    file_path = \"data/word_finder.txt\"\n    search_word = \"python\"\n    occurrences = lines_with_word_occurrences(file_path, search_word)\n    print(\n        f'A palavra \"{search_word}\" ocorre nas seguintes linhas do arquivo:',\n        occurrences,\n    )\nif __name__ == \"__main__\":\n    main()",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.src.word_finder",
        "documentation": {}
    },
    {
        "label": "sample_reader",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def sample_reader(path):\n    with open(path, \"r\") as file:\n        return list(csv.DictReader(file))\n@patch(\"src.spotify.read_csv\")\n@patch.object(sys, \"argv\", [\"script-name\"])\ndef test_spotify_analyzer_main_no_option(mock_reader, capsys):\n    exit_code = spotify.main(TEST_DATA_PATH)\n    assert exit_code == 1\n    captured = capsys.readouterr()\n    mock_reader.assert_not_called()",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_spotify_analyzer_main_no_option",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def test_spotify_analyzer_main_no_option(mock_reader, capsys):\n    exit_code = spotify.main(TEST_DATA_PATH)\n    assert exit_code == 1\n    captured = capsys.readouterr()\n    mock_reader.assert_not_called()\n    assert \"Modo de uso:\\n    python3 src/spotify.py [ opção ]\" in captured.out\n@patch.object(sys, \"argv\", [\"script-name\", \"INVALID\"])\ndef test_spotify_analyzer_invalid_option(capsys):\n    res = spotify.main(TEST_DATA_PATH)\n    assert res == 1",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_spotify_analyzer_invalid_option",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def test_spotify_analyzer_invalid_option(capsys):\n    res = spotify.main(TEST_DATA_PATH)\n    assert res == 1\n    captured = capsys.readouterr()\n    assert \"Opção 'INVALID' inválida.\" in captured.out\n@patch.object(sys, \"argv\", [\"script-name\", \"1\"])\n@patch(\"src.spotify.handle_user_input\")\n@patch(\"src.spotify.read_csv\")\n@patch(\"src.spotify.process_music_analysis\")\ndef test_spotify_analyzer_valid_option(",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_spotify_analyzer_valid_option",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def test_spotify_analyzer_valid_option(\n    mock_processer, mock_reader, mock_handler\n):\n    res = spotify.main(TEST_DATA_PATH)\n    assert res == 0\n    mock_reader.assert_called_once_with(TEST_DATA_PATH)\n    mock_handler.assert_called_once_with(mock_reader.return_value, \"1\")\n@patch.object(sys, \"argv\", [\"script-name\", \"2\"])\ndef test_spotify_analyzer_integration(capsys):\n    res = spotify.main(TEST_DATA_PATH)",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_spotify_analyzer_integration",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def test_spotify_analyzer_integration(capsys):\n    res = spotify.main(TEST_DATA_PATH)\n    assert res == 0\n    captured = capsys.readouterr()\n    assert captured.out == (\n        \"Top 10 músicas mais dançantes:\\n\"\n        \" 1 - 'Give It To Me' de Timbaland\\n\"\n        \" 2 - 'GIRL LIKE ME' de Black Eyed Peas\\n\"\n        \" 3 - 'Blueberry Yum Yum' de Ludacris\\n\"\n        \" 4 - 'Around the World' de Daft Punk\\n\"",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_spotify_handler_calls_processor",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def test_spotify_handler_calls_processor(mock_processor):\n    csv_data = [{\"fake_key\": \"fake_value\"}]\n    spotify.handle_user_input(csv_data, \"1\")\n    mock_processor.assert_called_once_with(csv_data, \"1\")\ndef test_spotify_handler_raises_when_invalid_option():\n    csv_data = [{\"fake_key\": \"fake_value\"}]\n    with pytest.raises(ValueError):\n        spotify.handle_user_input(csv_data, \"INVALID\")\ndef test_spotify_processor_calls_get_most_instrumental_songs():\n    csv_data = sample_reader(TEST_DATA_PATH)",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_spotify_handler_raises_when_invalid_option",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def test_spotify_handler_raises_when_invalid_option():\n    csv_data = [{\"fake_key\": \"fake_value\"}]\n    with pytest.raises(ValueError):\n        spotify.handle_user_input(csv_data, \"INVALID\")\ndef test_spotify_processor_calls_get_most_instrumental_songs():\n    csv_data = sample_reader(TEST_DATA_PATH)\n    res = spotify.get_most_instrumental_songs(csv_data)\n    for i in range(len(res) - 1):\n        assert res[i][\"Instrumentalness\"] >= res[i + 1][\"Instrumentalness\"]\ndef test_spotify_processor_calls_get_most_danceable_songs():",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_spotify_processor_calls_get_most_instrumental_songs",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def test_spotify_processor_calls_get_most_instrumental_songs():\n    csv_data = sample_reader(TEST_DATA_PATH)\n    res = spotify.get_most_instrumental_songs(csv_data)\n    for i in range(len(res) - 1):\n        assert res[i][\"Instrumentalness\"] >= res[i + 1][\"Instrumentalness\"]\ndef test_spotify_processor_calls_get_most_danceable_songs():\n    csv_data = sample_reader(TEST_DATA_PATH)\n    res = spotify.get_most_danceable_songs(csv_data)\n    for i in range(len(res) - 1):\n        assert res[i][\"Danceability\"] >= res[i + 1][\"Danceability\"]",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_spotify_processor_calls_get_most_danceable_songs",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def test_spotify_processor_calls_get_most_danceable_songs():\n    csv_data = sample_reader(TEST_DATA_PATH)\n    res = spotify.get_most_danceable_songs(csv_data)\n    for i in range(len(res) - 1):\n        assert res[i][\"Danceability\"] >= res[i + 1][\"Danceability\"]\ndef test_spotify_processor_calls_get_most_energetic_songs():\n    csv_data = sample_reader(TEST_DATA_PATH)\n    res = spotify.get_most_energetic_songs(csv_data)\n    for i in range(len(res) - 1):\n        assert res[i][\"Energy\"] >= res[i + 1][\"Energy\"]",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_spotify_processor_calls_get_most_energetic_songs",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def test_spotify_processor_calls_get_most_energetic_songs():\n    csv_data = sample_reader(TEST_DATA_PATH)\n    res = spotify.get_most_energetic_songs(csv_data)\n    for i in range(len(res) - 1):\n        assert res[i][\"Energy\"] >= res[i + 1][\"Energy\"]\n@pytest.mark.dependency(\n    depends=[\n        \"test_spotify_analyzer_main_no_option\",\n        \"test_spotify_analyzer_invalid_option\",\n        \"test_spotify_analyzer_valid_option\",",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_spotify_final",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "def test_spotify_final():\n    pass",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "TEST_DATA_PATH",
        "kind": 5,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "TEST_DATA_PATH = \"tests/test_data/spotify.csv\"\npytestmark = pytest.mark.dependency()\ndef sample_reader(path):\n    with open(path, \"r\") as file:\n        return list(csv.DictReader(file))\n@patch(\"src.spotify.read_csv\")\n@patch.object(sys, \"argv\", [\"script-name\"])\ndef test_spotify_analyzer_main_no_option(mock_reader, capsys):\n    exit_code = spotify.main(TEST_DATA_PATH)\n    assert exit_code == 1",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "pytestmark",
        "kind": 5,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "peekOfCode": "pytestmark = pytest.mark.dependency()\ndef sample_reader(path):\n    with open(path, \"r\") as file:\n        return list(csv.DictReader(file))\n@patch(\"src.spotify.read_csv\")\n@patch.object(sys, \"argv\", [\"script-name\"])\ndef test_spotify_analyzer_main_no_option(mock_reader, capsys):\n    exit_code = spotify.main(TEST_DATA_PATH)\n    assert exit_code == 1\n    captured = capsys.readouterr()",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_spotify",
        "documentation": {}
    },
    {
        "label": "test_lines_with_word_occurrences",
        "kind": 2,
        "importPath": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_word_finder",
        "description": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_word_finder",
        "peekOfCode": "def test_lines_with_word_occurrences():\n    file_path = \"tests/test_data/word_finder.txt\"\n    search_word = \"python\"\n    occurrences = lines_with_word_occurrences(file_path, search_word)\n    assert occurrences == [1, 2, 3, 4, 6, 8]",
        "detail": "the_bug_hunting.python-001-exercicio-the-bug-hunting.tests.test_word_finder",
        "documentation": {}
    },
    {
        "label": "insertion_sort",
        "kind": 2,
        "importPath": "insertion_sort",
        "description": "insertion_sort",
        "peekOfCode": "def insertion_sort(array):\n    for i in range(1, len(array)):\n        current_value = array[i]\n        position = i\n        while position > 0 and array[position - 1] > current_value:\n            array[position] = array[position - 1]\n            position -= 1\n        array[position] = current_value\n    return array\ndef main():",
        "detail": "insertion_sort",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "insertion_sort",
        "description": "insertion_sort",
        "peekOfCode": "def main():\n    array = [23, 423, 1, 54, 8, 980, 45, 768, 34, 55, 88, 99, 100, 234, 567]\n    sorted_array = insertion_sort(array)\n    print(f\"Array ordenado: {sorted_array}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "insertion_sort",
        "documentation": {}
    },
    {
        "label": "map_factorial",
        "kind": 2,
        "importPath": "testando",
        "description": "testando",
        "peekOfCode": "def map_factorial(numbers):\n    result = []\n    for num in numbers:\n        result.append(factorial(num))\n    return result\ndef main():\n    input_list = [1, 2, 3, 4, 5]\n    return map_factorial(input_list)\nif __name__ == \"__main__\":\n    print(main())",
        "detail": "testando",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "testando",
        "description": "testando",
        "peekOfCode": "def main():\n    input_list = [1, 2, 3, 4, 5]\n    return map_factorial(input_list)\nif __name__ == \"__main__\":\n    print(main())",
        "detail": "testando",
        "documentation": {}
    },
    {
        "label": "generate_int_description",
        "kind": 2,
        "importPath": "text_to_speech",
        "description": "text_to_speech",
        "peekOfCode": "def generate_int_description(integer):\n    \"\"\"Transformar digitos de número em texto PT-BR\"\"\"\n    digits = list(str(integer))\n    description = f\"{DIGITS_MAP.get(int(digits[0]))}\"\n    for digit in digits[1:]:\n        description += f\" {DIGITS_MAP.get(int(digit))}\"\n    return description\ndef main():\n    integer = randint(10000, 99999)\n    description = generate_int_description(integer)",
        "detail": "text_to_speech",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "text_to_speech",
        "description": "text_to_speech",
        "peekOfCode": "def main():\n    integer = randint(10000, 99999)\n    description = generate_int_description(integer)\n    print(f\"Descrição do número{integer}: {description}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "text_to_speech",
        "documentation": {}
    },
    {
        "label": "DIGITS_MAP",
        "kind": 5,
        "importPath": "text_to_speech",
        "description": "text_to_speech",
        "peekOfCode": "DIGITS_MAP = {\n    0: \"zero\",\n    1: \"um\",\n    2: \"dois\",\n    3: \"três\",\n    4: \"quatro\",\n    5: \"cinco\",\n    6: \"seis\",\n    7: \"sete\",\n    8: \"oito\",",
        "detail": "text_to_speech",
        "documentation": {}
    }
]